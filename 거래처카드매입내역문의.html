<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>거래처 카드매입내역 문의 자동화 </title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; user-select: none; }
        .table-preview-container { max-height: 50vh; overflow: auto; }
        .preview-table { border-collapse: collapse; width: 100%; font-size: 0.8rem; }
        .preview-table th, .preview-table td {
            border: 1px solid #e2e8f0; padding: 0.5rem; text-align: left;
            white-space: nowrap; min-width: 50px;
        }
        .preview-table th { background-color: #f8fafc; font-weight: 600; position: sticky; top: 0; z-index: 10;}
        .preview-table th.sortable { cursor: pointer; }
        .preview-table th.sortable:hover { background-color: #f1f5f9; }
        .preview-table th .sort-indicator { display: inline-block; margin-left: 5px; opacity: 0.5; }
        
        .row-selectable:hover { background-color: #f0f9ff; cursor: pointer; }
        .col-selectable:hover { background-color: #f0f9ff; cursor: pointer; }
        .col-selectable-header { cursor: pointer; }
        .col-selectable-header:hover { background-color: #e0e7ff; }
        .col-selected { background-color: #fb7185 !important; color: white; }
        .col-mandatory { background-color: #e5e7eb !important; color: #6b7280; cursor: not-allowed; }
        
        .highlight-row { background-color: #bae6fd !important; }
        .highlight-col { background-color: #93c5fd !important; }
        .highlight-select { background-color: #60a5fa !important; color: white; }

        .list-box { min-height: 300px; max-height: 400px; overflow-y: auto; }
        .list-item { cursor: grab; transition: background-color 0.2s; }
        .list-item:hover { background-color: #f1f5f9; }
        .list-item.dragging { opacity: 0.5; }


        .step-indicator {
            transition: all 0.3s ease-in-out;
            border-bottom-width: 4px;
        }
        .step-inactive { border-color: transparent; color: #64748b; }
        .step-active { border-color: #4f46e5; color: #4f46e5; font-weight: 600; }
        .step-complete { border-color: #16a34a; color: #15803d; }
        
        .drop-zone {
            transition: all 0.2s ease;
            min-height: 40px;
        }
        .drop-zone.drag-over {
            background-color: #e0f2fe;
            border-color: #3b82f6;
            transform: scale(1.02);
        }
        .mapped-item {
            cursor: pointer;
        }
        .mapped-item:hover {
            opacity: 0.8;
            text-decoration: line-through;
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 flex items-center justify-center min-h-screen p-4">

    <div id="app" class="w-full max-w-7xl bg-white p-8 rounded-xl shadow-lg space-y-8">
        
        <!-- Initial Choice Screen -->
        <div id="initial-choice-container">
            <h1 class="text-3xl font-bold text-center text-slate-900">거래처 카드매입내역 문의 자동화</h1>
            <p class="text-slate-600 text-center mt-2 mb-8">수행할 작업을 선택하세요.</p>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-12">
                <button id="start-inquiry-btn" class="flex flex-col items-center justify-center p-8 bg-slate-50 rounded-lg shadow-sm hover:shadow-xl hover:bg-white transition-all transform hover:-translate-y-1">
                    <h2 class="text-xl font-bold text-indigo-600">거래처 매입내역 문의 자동화</h2>
                    <p class="text-slate-500 mt-2 text-center">엑셀을 업로드하여 문의할 내역을 분류하고, 업체 전송용 엑셀 파일을 생성합니다.</p>
                </button>
                <button id="start-merge-btn" class="flex flex-col items-center justify-center p-8 bg-slate-50 rounded-lg shadow-sm hover:shadow-xl hover:bg-white transition-all transform hover:-translate-y-1">
                    <h2 class="text-xl font-bold text-teal-600">업체 회신내역 정리</h2>
                    <p class="text-slate-500 mt-2 text-center">업체에서 회신받은 엑셀에서 기입한 부분만 반영하고, 기존 내용은 유지합니다.</p>
                </button>
            </div>
            <div class="mt-12 p-6 bg-slate-100 rounded-lg">
                <h3 class="text-lg font-semibold text-slate-800 mb-4">&lt;추천 사용방법&gt;</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 text-sm">
                    <div>
                        <h4 class="font-bold mb-2">작업 전</h4>
                        <ol class="list-decimal list-inside space-y-1 text-slate-600">
                            <li>수지라에서 스크래핑</li>
                            <li>붙여넣기 > 카드매입내역 내보내기</li>
                            <li>수지라에서 만들어진 엑셀로 작업</li>
                        </ol>
                    </div>
                    <div>
                        <h4 class="font-bold mb-2">작업 후</h4>
                        <ol class="list-decimal list-inside space-y-1 text-slate-600">
                            <li>수지라 스크래핑된 카드매입내역 삭제</li>
                            <li>붙여넣기 > 카드,현영 > 카드사_엑셀</li>
                            <li>'문의하지 않은 나머지' 시트 업로드
                                <ul class="list-disc list-inside ml-4">
                                    <li>업체 회신전 미리 작업해도 됩니다.</li>
                                </ul>
                            </li>
                            <li>업체에서 회신받은 자료 업로드</li>
                            <li>작업 완료 후 세무사랑으로 업로드</li>
                        </ol>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Inquiry Workflow Container -->
        <div id="inquiry-workflow-container" class="hidden">
            <button class="back-to-main-btn mb-4 px-4 py-2 text-sm bg-slate-200 rounded-md hover:bg-slate-300">← 처음으로</button>
            <!-- Step Indicator -->
            <div class="flex border-b">
                <div id="step-nav-1" class="step-indicator flex-1 text-center p-4">1단계: 1차 분류</div>
                <div id="step-nav-2" class="step-indicator flex-1 text-center p-4">2단계: 상세 분류</div>
                <div id="step-nav-3" class="step-indicator flex-1 text-center p-4">3단계: 업체 전송내역 설정</div>
            </div>
            <div id="step1-container" class="hidden">
                 <!-- Step 1 content -->
                 <div id="upload-step">
                    <label for="file-input" class="flex flex-col items-center justify-center h-64 border-2 border-dashed rounded-lg bg-slate-50 cursor-pointer hover:bg-slate-100 transition mt-8">
                        <svg class="w-12 h-12 mb-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                        <span class="text-slate-600 font-medium text-lg">클릭하여 XLSX/XLS 파일 업로드</span>
                        <input id="file-input" type="file" accept=".xlsx,.xls" class="hidden"/>
                    </label>
                </div>
                <div id="processing-step" class="hidden space-y-6">
                    <div>
                        <h2 id="instruction" class="text-2xl font-bold text-slate-900"></h2>
                        <p class="text-slate-500">테이블에서 해당하는 행 또는 열 전체를 클릭하세요.</p>
                    </div>
                    <div class="table-preview-container border rounded-lg">
                        <table id="preview-table" class="preview-table"></table>
                    </div>
                    <div class="text-right">
                        <button id="confirm-btn" class="px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 disabled:bg-indigo-300 disabled:cursor-not-allowed" disabled>확인</button>
                    </div>
                </div>
                <div id="client-selection-step" class="hidden">
                     <h2 class="text-2xl font-bold text-slate-900 mb-4">3. 문의할 거래처 선택</h2>
                     <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h3 class="font-semibold mb-2 text-center">거래처 목록 (<span id="source-count">0</span>)</h3>
                            <div id="source-list" class="list-box border rounded-md p-2 space-y-1 bg-slate-50"></div>
                        </div>
                         <div>
                            <h3 class="font-semibold mb-2 text-center">문의할 거래처 내역 (<span id="target-count">0</span>)</h3>
                            <div id="target-list" class="list-box border rounded-md p-2 space-y-1 bg-blue-50"></div>
                        </div>
                     </div>
                     <div class="text-right mt-6">
                         <button id="complete-step1-btn" class="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">1차 분류 완료 (2단계로)</button>
                     </div>
                </div>
            </div>
            <div id="step2-container" class="hidden space-y-6">
                <!-- Step 2 content -->
                 <h2 class="text-2xl font-bold text-slate-900">2단계: 상세 분류</h2>
                 <p class="text-slate-500">문의할 거래내역을 확인하고 불필요한 항목을 제거하세요. (엑셀처럼 Ctrl, Shift 키로 다중선택 가능)</p>
                 <div class="flex items-center space-x-4">
                     <button id="remove-rows-btn" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600">선택 행 제거</button>
                     <button id="reset-step2-btn" class="px-4 py-2 bg-slate-500 text-white rounded-md hover:bg-slate-600">초기화</button>
                 </div>
                 <div class="table-preview-container border rounded-lg">
                     <table id="step2-preview-table" class="preview-table"></table>
                 </div>
                 <div class="text-right">
                     <button id="confirm-step2-btn" class="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">문의 내역 확정 (3단계로)</button>
                 </div>
            </div>
            <div id="step3-container" class="hidden space-y-6">
                 <!-- Step 3 content -->
                 <h2 class="text-2xl font-bold text-slate-900">3단계: 업체 전송 내역 최종 선택</h2>
                 <p class="text-slate-500">업체에 전송할 내역 중 <span class="font-bold text-red-500">전송하지 않을 열</span>을 제목 행에서 클릭하여 선택하세요. (다중 선택 가능)</p>
                 <div class="flex items-center space-x-4">
                    <button id="remove-cols-btn" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600">선택 열 제거</button>
                    <button id="reset-step3-btn" class="px-4 py-2 bg-slate-500 text-white rounded-md hover:bg-slate-600">초기화</button>
                </div>
                 <div class="table-preview-container border rounded-lg">
                    <table id="step3-preview-table" class="preview-table"></table>
                </div>
                <div class="text-right">
                    <button id="export-excel-btn" class="px-6 py-2 bg-emerald-600 text-white rounded-md hover:bg-emerald-700">확인 및 엑셀 저장</button>
                </div>
            </div>
        </div>
        
        <!-- Merge Workflow Container -->
        <div id="merge-workflow-container" class="hidden">
            <button class="back-to-main-btn mb-4 px-4 py-2 text-sm bg-slate-200 rounded-md hover:bg-slate-300">← 처음으로</button>
            <h1 class="text-2xl font-bold text-slate-900">업체 회신내역 정리</h1>
            <!-- Merge Step 1: Upload -->
            <div id="merge-upload-step" class="space-y-6 mt-4">
                <p class="text-slate-500">업체에서 회신받은 엑셀 파일을 업로드하세요.</p>
                <label for="merge-file-input" class="flex flex-col items-center justify-center h-64 border-2 border-dashed rounded-lg bg-slate-50 cursor-pointer hover:bg-slate-100 transition">
                    <svg class="w-12 h-12 mb-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
                    <span class="text-slate-600 font-medium text-lg">클릭하여 회신받은 XLSX/XLS 파일 업로드</span>
                    <input id="merge-file-input" type="file" accept=".xlsx,.xls" class="hidden"/>
                </label>
            </div>
             <!-- Merge Step 2: Select Header -->
            <div id="merge-header-step" class="hidden space-y-6 mt-4">
                 <h2 class="text-xl font-bold text-slate-900">1. 제목 행을 선택하세요.</h2>
                 <div class="table-preview-container border rounded-lg">
                    <table id="merge-preview-table" class="preview-table"></table>
                 </div>
                 <div class="text-right">
                    <button id="merge-confirm-header-btn" class="px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 disabled:bg-indigo-300" disabled>확인</button>
                </div>
            </div>
            <!-- Merge Step 3: Map Columns -->
            <div id="merge-map-step" class="hidden space-y-6 mt-4">
                <h2 class="text-xl font-bold text-slate-900">2. 열을 드래그하여 매핑하세요.</h2>
                <p class="text-slate-500">왼쪽의 열 제목을 오른쪽의 해당 영역으로 끌어다 놓으세요. '업체 기재 내용'이 '기존 내용'을 덮어씁니다.</p>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <!-- Source Columns -->
                    <div class="md:col-span-1">
                        <h3 class="font-semibold mb-2 text-center">회신 파일 열 리스트</h3>
                        <div id="merge-source-cols" class="list-box border rounded-md p-2 space-y-1 bg-slate-50"></div>
                    </div>
                    <!-- Target Mapping -->
                    <div class="md:col-span-2">
                        <div class="grid grid-cols-2 gap-4">
                            <h3 class="font-semibold text-center text-blue-600">업체 기재 내용 (덮어쓰는 값)</h3>
                            <h3 class="font-semibold text-center text-green-600">기존 내용 (덮어쓰기 대상)</h3>
                        </div>
                        <div id="merge-map-pairs" class="space-y-3 mt-2">
                            <!-- Mapping pairs will be generated by JS -->
                        </div>
                    </div>
                </div>
                 <div class="text-right">
                    <button id="merge-confirm-map-btn" class="px-6 py-2 bg-green-600 text-white rounded-md hover:bg-green-700">병합 및 미리보기</button>
                </div>
            </div>
             <!-- Merge Step 4: Final Preview & Download -->
             <div id="merge-preview-step" class="hidden space-y-6 mt-4">
                <h2 class="text-xl font-bold text-slate-900">3. 최종 결과 미리보기</h2>
                <div class="table-preview-container border rounded-lg">
                    <table id="merge-final-preview-table" class="preview-table"></table>
                </div>
                <div class="text-right">
                    <button id="merge-export-btn" class="px-6 py-2 bg-emerald-600 text-white rounded-md hover:bg-emerald-700">최종 엑셀 저장</button>
                </div>
            </div>
        </div>

    </div>

    <script>
        // Main App State
        const appState = {
            mode: 'initial', // 'initial', 'inquiry', 'merge'
        };

        // Inquiry Workflow State
        const state = {
            fileName: '자동화_결과.xlsx',
            originalRawData: [], 
            rawData: [],
            headerRowIndex: null,
            clientColIndex: null,
            mainStep: 1,
            step1: { currentSubStep: 'upload', sourceClients: new Set(), targetClients: new Set() },
            step2: { initialData: [], currentData: [], header: [], selectedRows: new Set(), lastSelectedRowIndex: -1, sortState: { colIndex: -1, direction: 'asc' } },
            step3: { initialData: [], initialHeader: [], currentData: [], currentHeader: [], mandatoryColIndices: new Set(), selectedColIndices: new Set(), removedColIndices: new Set() }
        };

        // Merge Workflow State
        const mergeState = {
            fileName: '회신내역_정리.xlsx',
            replyData: [],
            replyHeader: [],
            replyHeaderIndex: null,
            currentStep: 'upload', // 'upload', 'selectHeader', 'mapColumns', 'preview'
            mappings: [
                { reply: null, original: null, label: '거래처명' },
                { reply: null, original: null, label: '사업자등록번호' },
                { reply: null, original: null, label: '품목' }
            ],
            finalData: [],
            finalHeader: []
        };


        // --- DOM Elements ---
        const initialChoiceContainer = document.getElementById('initial-choice-container');
        const inquiryWorkflowContainer = document.getElementById('inquiry-workflow-container');
        const mergeWorkflowContainer = document.getElementById('merge-workflow-container');
        const startInquiryBtn = document.getElementById('start-inquiry-btn');
        const startMergeBtn = document.getElementById('start-merge-btn');
        document.querySelectorAll('.back-to-main-btn').forEach(btn => btn.addEventListener('click', showInitialChoice));

        // Inquiry Elements
        const stepNavs = [document.getElementById('step-nav-1'), document.getElementById('step-nav-2'), document.getElementById('step-nav-3')];
        const stepContainers = [document.getElementById('step1-container'), document.getElementById('step2-container'), document.getElementById('step3-container')];
        const uploadStepEl = document.getElementById('upload-step');
        const processingStepEl = document.getElementById('processing-step');
        const clientSelectionStepEl = document.getElementById('client-selection-step');
        const fileInputEl = document.getElementById('file-input');
        const instructionEl = document.getElementById('instruction');
        const previewTableEl = document.getElementById('preview-table');
        const confirmBtnEl = document.getElementById('confirm-btn');
        const sourceListEl = document.getElementById('source-list');
        const targetListEl = document.getElementById('target-list');
        const sourceCountEl = document.getElementById('source-count');
        const targetCountEl = document.getElementById('target-count');
        const completeStep1BtnEl = document.getElementById('complete-step1-btn');
        const step2PreviewTableEl = document.getElementById('step2-preview-table');
        const removeRowsBtnEl = document.getElementById('remove-rows-btn');
        const resetStep2BtnEl = document.getElementById('reset-step2-btn');
        const confirmStep2BtnEl = document.getElementById('confirm-step2-btn');
        const step3PreviewTableEl = document.getElementById('step3-preview-table');
        const removeColsBtnEl = document.getElementById('remove-cols-btn');
        const resetStep3BtnEl = document.getElementById('reset-step3-btn');
        const exportExcelBtnEl = document.getElementById('export-excel-btn');

        // Merge Elements
        const mergeUploadStep = document.getElementById('merge-upload-step');
        const mergeHeaderStep = document.getElementById('merge-header-step');
        const mergeMapStep = document.getElementById('merge-map-step');
        const mergePreviewStep = document.getElementById('merge-preview-step');
        const mergeFileInput = document.getElementById('merge-file-input');
        const mergePreviewTable = document.getElementById('merge-preview-table');
        const mergeConfirmHeaderBtn = document.getElementById('merge-confirm-header-btn');
        const mergeSourceCols = document.getElementById('merge-source-cols');
        const mergeMapPairs = document.getElementById('merge-map-pairs');
        const mergeConfirmMapBtn = document.getElementById('merge-confirm-map-btn');
        const mergeFinalPreviewTable = document.getElementById('merge-final-preview-table');
        const mergeExportBtn = document.getElementById('merge-export-btn');

        // --- Event Listeners ---
        startInquiryBtn.addEventListener('click', () => startWorkflow('inquiry'));
        startMergeBtn.addEventListener('click', () => startWorkflow('merge'));

        // Inquiry Listeners
        fileInputEl.addEventListener('change', handleFile);
        confirmBtnEl.addEventListener('click', handleStep1Confirm);
        completeStep1BtnEl.addEventListener('click', handleCompleteStep1);
        removeRowsBtnEl.addEventListener('click', handleRemoveRows);
        resetStep2BtnEl.addEventListener('click', handleResetStep2);
        confirmStep2BtnEl.addEventListener('click', handleConfirmStep2);
        removeColsBtnEl.addEventListener('click', handleRemoveCols);
        resetStep3BtnEl.addEventListener('click', handleResetStep3);
        exportExcelBtnEl.addEventListener('click', handleExportExcel);
        
        // Merge Listeners
        mergeFileInput.addEventListener('change', handleMergeFile);
        mergeConfirmHeaderBtn.addEventListener('click', handleMergeConfirmHeader);
        mergeConfirmMapBtn.addEventListener('click', handleMergeConfirmMap);
        mergeExportBtn.addEventListener('click', handleMergeExport);

        // --- Main App Flow ---
        function startWorkflow(mode) {
            appState.mode = mode;
            updateUI();
        }

        function showInitialChoice() {
            appState.mode = 'initial';
            // Reset states properly
            resetInquiryState();
            resetMergeState();
            // **[BUG FIX 2]** Reset file input values
            fileInputEl.value = '';
            mergeFileInput.value = '';
            updateUI();
        }

        function resetInquiryState() {
            Object.assign(state, {
                fileName: '자동화_결과.xlsx',
                originalRawData: [], 
                rawData: [],
                headerRowIndex: null,
                clientColIndex: null,
                mainStep: 1,
                step1: { currentSubStep: 'upload', sourceClients: new Set(), targetClients: new Set() },
                step2: { initialData: [], currentData: [], header: [], selectedRows: new Set(), lastSelectedRowIndex: -1, sortState: { colIndex: -1, direction: 'asc' } },
                step3: { initialData: [], initialHeader: [], currentData: [], currentHeader: [], mandatoryColIndices: new Set(), selectedColIndices: new Set(), removedColIndices: new Set() }
            });
        }

        function resetMergeState() {
            Object.assign(mergeState, {
                fileName: '회신내역_정리.xlsx',
                replyData: [],
                replyHeader: [],
                replyHeaderIndex: null,
                currentStep: 'upload',
                mappings: [
                    { reply: null, original: null, label: '거래처명' },
                    { reply: null, original: null, label: '사업자등록번호' },
                    { reply: null, original: null, label: '품목' }
                ],
                finalData: [],
                finalHeader: []
            });
        }

        // --- Inquiry Workflow Functions (from handleFile to handleExportExcel) ---
        // (Existing functions from v3.9 are placed here, unchanged)
        // ...
        
        // --- Step 1 Functions ---
        function handleFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            state.fileName = file.name.replace(/\.(xlsx|xls)$/, '') + '_결과.xlsx';
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                let rawData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });

                const initialKeywordsToRemove = ["수 량", "단 가", "대표자", "업 태", "종 목", "사업장주소"];
                const filteredData = rawData.filter(row => {
                    const firstCell = String(row[0]).trim();
                    return !initialKeywordsToRemove.some(keyword => firstCell.startsWith(keyword));
                });
                state.originalRawData = JSON.parse(JSON.stringify(filteredData)); // Keep a clean copy
                state.rawData = filteredData;
                
                state.step1.currentSubStep = 'select-header';
                updateUI();
            };
            reader.readAsArrayBuffer(file);
        }

        function handleStep1Confirm() {
            if (state.step1.currentSubStep === 'select-header') {
                if (state.headerRowIndex === null) { alert('제목 행을 선택해주세요.'); return; }

                const originalHeader = state.rawData[state.headerRowIndex];
                
                const colKeywordsToRemove = ["수 량", "단 가", "대표자", "업 태", "종 목", "사업장주소"];
                const indicesToRemove = new Set();
                originalHeader.forEach((headerText, index) => {
                    if (colKeywordsToRemove.some(keyword => String(headerText).trim().startsWith(keyword))) {
                        indicesToRemove.add(index);
                    }
                });

                const newHeader = originalHeader.filter((_, index) => !indicesToRemove.has(index));
                
                const dateKeyword = "승인일자";
                const dateColIndex = originalHeader.findIndex(h => String(h).includes(dateKeyword));
                
                let dataRows = state.rawData.slice(state.headerRowIndex + 1);

                if (dateColIndex !== -1) {
                    dataRows = dataRows.filter(row => row[dateColIndex] && String(row[dateColIndex]).trim() !== '');
                }

                const newRows = dataRows.map(row => row.filter((_, index) => !indicesToRemove.has(index)));
                
                state.rawData = [newHeader, ...newRows];
                state.originalRawData = JSON.parse(JSON.stringify(state.rawData)); 
                state.headerRowIndex = 0; 
                
                state.step1.currentSubStep = 'select-column';
            } else if (state.step1.currentSubStep === 'select-column') {
                if (state.clientColIndex === null) { alert('거래처명이 있는 열을 선택해주세요.'); return; }
                populateClientLists();
                state.step1.currentSubStep = 'select-clients';
            }
            updateUI();
        }

        function populateClientLists() {
            const dataAfterHeader = state.rawData.slice(state.headerRowIndex + 1);
            const clients = dataAfterHeader
                .map(row => row[state.clientColIndex])
                .filter(client => client !== null && client !== undefined && String(client).trim() !== '');
            state.step1.sourceClients = new Set(clients);
            state.step1.targetClients = new Set();
        }

        function renderStep1Table() {
            previewTableEl.innerHTML = '';
            const previewData = state.rawData.slice(0, 20);
            const tbody = document.createElement('tbody');
            previewData.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                if (state.step1.currentSubStep === 'select-header') {
                    tr.classList.add('row-selectable');
                    if (state.headerRowIndex === rowIndex) tr.classList.add('highlight-row');
                    tr.addEventListener('click', () => handleRowClick(rowIndex));
                }
                row.forEach((cell, colIndex) => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    if (state.step1.currentSubStep === 'select-column') {
                        td.classList.add('col-selectable');
                        if (state.clientColIndex === colIndex) td.classList.add('highlight-col');
                        td.addEventListener('click', () => handleColClick(colIndex));
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            previewTableEl.appendChild(tbody);
        }

        function handleRowClick(rowIndex) {
            if (state.step1.currentSubStep !== 'select-header') return;
            state.headerRowIndex = rowIndex;
            confirmBtnEl.disabled = false;
            renderStep1Table();
        }

        function handleColClick(colIndex) {
            if (state.step1.currentSubStep !== 'select-column') return;
            state.clientColIndex = colIndex;
            confirmBtnEl.disabled = false;
            renderStep1Table();
        }
        
        function renderClientLists() {
            sourceListEl.innerHTML = '';
            targetListEl.innerHTML = '';
            const sortedSource = [...state.step1.sourceClients].sort();
            sortedSource.forEach(client => {
                if (!state.step1.targetClients.has(client)) {
                    const div = document.createElement('div');
                    div.textContent = client;
                    div.className = 'list-item p-2 rounded';
                    div.onclick = () => moveClient(client, 'toTarget');
                    sourceListEl.appendChild(div);
                }
            });
            const sortedTarget = [...state.step1.targetClients].sort();
            sortedTarget.forEach(client => {
                const div = document.createElement('div');
                div.textContent = client;
                div.className = 'list-item p-2 rounded';
                div.onclick = () => moveClient(client, 'toSource');
                targetListEl.appendChild(div);
            });
            sourceCountEl.textContent = sourceListEl.children.length;
            targetCountEl.textContent = targetListEl.children.length;
        }

        function moveClient(client, direction) {
            if (direction === 'toTarget') {
                state.step1.targetClients.add(client);
            } else {
                state.step1.targetClients.delete(client);
            }
            renderClientLists();
        }

        function handleCompleteStep1() {
            if (state.step1.targetClients.size === 0) {
                alert('문의할 거래처를 1개 이상 선택해주세요.');
                return;
            }
            state.step2.header = state.rawData[state.headerRowIndex];
            const inquiryData = state.rawData.slice(state.headerRowIndex + 1)
                .filter(row => state.step1.targetClients.has(row[state.clientColIndex]));
            state.step2.initialData = JSON.parse(JSON.stringify(inquiryData));
            state.step2.currentData = JSON.parse(JSON.stringify(inquiryData));
            state.mainStep = 2;
            updateUI();
        }

        // --- Step 2 Functions ---
        function renderStep2Table() {
            step2PreviewTableEl.innerHTML = '';
            const { currentData, header, sortState, selectedRows } = state.step2;
            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            header.forEach((title, index) => {
                const th = document.createElement('th');
                th.textContent = title;
                th.classList.add('sortable');
                th.dataset.colIndex = index;
                if(sortState.colIndex === index) {
                    const indicator = document.createElement('span');
                    indicator.className = 'sort-indicator';
                    indicator.textContent = sortState.direction === 'asc' ? '▲' : '▼';
                    th.appendChild(indicator);
                }
                th.addEventListener('click', () => handleSort(index));
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            step2PreviewTableEl.appendChild(thead);
            const tbody = document.createElement('tbody');
            currentData.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                tr.dataset.rowIndex = rowIndex;
                tr.classList.add('row-selectable');
                if (selectedRows.has(rowIndex)) tr.classList.add('highlight-select');
                tr.addEventListener('click', (e) => handleStep2RowClick(e, rowIndex));
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            step2PreviewTableEl.appendChild(tbody);
        }
        
        function handleStep2RowClick(event, rowIndex) {
            const { selectedRows } = state.step2;
            if (event.shiftKey && state.step2.lastSelectedRowIndex > -1) {
                selectedRows.clear();
                const start = Math.min(state.step2.lastSelectedRowIndex, rowIndex);
                const end = Math.max(state.step2.lastSelectedRowIndex, rowIndex);
                for (let i = start; i <= end; i++) selectedRows.add(i);
            } else if (event.ctrlKey || event.metaKey) {
                if (selectedRows.has(rowIndex)) selectedRows.delete(rowIndex);
                else selectedRows.add(rowIndex);
                state.step2.lastSelectedRowIndex = rowIndex;
            } else {
                selectedRows.clear();
                selectedRows.add(rowIndex);
                state.step2.lastSelectedRowIndex = rowIndex;
            }
            renderStep2Table();
        }

        function handleSort(colIndex) {
            const { sortState } = state.step2;
            const direction = (sortState.colIndex === colIndex && sortState.direction === 'asc') ? 'desc' : 'asc';
            state.step2.currentData.sort((a, b) => {
                let valA = a[colIndex]; let valB = b[colIndex];
                if (String(valA).match(/^-?\d+(\.\d+)?$/) && String(valB).match(/^-?\d+(\.\d+)?$/)) {
                    return direction === 'asc' ? parseFloat(valA) - parseFloat(valB) : parseFloat(valB) - parseFloat(valA);
                }
                return direction === 'asc' ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
            });
            sortState.colIndex = colIndex; sortState.direction = direction;
            state.step2.selectedRows.clear(); state.step2.lastSelectedRowIndex = -1;
            renderStep2Table();
        }

        function handleRemoveRows() {
            if (state.step2.selectedRows.size === 0) { alert('제거할 행을 먼저 선택해주세요.'); return; }
            state.step2.currentData = state.step2.currentData.filter((_, index) => !state.step2.selectedRows.has(index));
            state.step2.selectedRows.clear(); state.step2.lastSelectedRowIndex = -1;
            renderStep2Table();
        }
        
        function handleResetStep2() {
            state.step2.currentData = JSON.parse(JSON.stringify(state.step2.initialData));
            state.step2.selectedRows.clear(); state.step2.lastSelectedRowIndex = -1;
            state.step2.sortState = { colIndex: -1, direction: 'asc' };
            renderStep2Table();
        }

        function handleConfirmStep2() {
            const initialDataCopy = JSON.parse(JSON.stringify(state.step2.currentData));
            state.step3.initialData = initialDataCopy;
            state.step3.currentData = initialDataCopy;
            state.step3.initialHeader = [...state.step2.header];
            state.step3.currentHeader = [...state.step2.header];
            state.step3.removedColIndices.clear(); // Reset for the new step
            identifyMandatoryColumns();
            state.mainStep = 3;
            updateUI();
        }
        
        // --- Step 3 Functions ---
        function identifyMandatoryColumns() {
            const mandatoryKeywords = ["신용카드명", "신용카드번호", "승인일자", "사업자등록번호", "거래처명", "합계금액", "품 목(적 요)"]
                .map(k => k.replace(/\s+/g, ' ').trim());
            
            state.step3.mandatoryColIndices.clear();
            
            state.step3.initialHeader.forEach((headerText, index) => {
                const normalizedHeaderText = String(headerText).replace(/\s+/g, ' ').trim();
                if (mandatoryKeywords.some(keyword => normalizedHeaderText.startsWith(keyword))) {
                    state.step3.mandatoryColIndices.add(index);
                }
            });
        }

        function renderStep3Table() {
            step3PreviewTableEl.innerHTML = '';
            const { currentData, currentHeader, mandatoryColIndices, selectedColIndices } = state.step3;
            
            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            currentHeader.forEach((title, currentIdx) => {
                const initialIdx = state.step3.initialHeader.indexOf(title);
                const th = document.createElement('th');
                th.textContent = title;

                if (mandatoryColIndices.has(initialIdx)) {
                    th.classList.add('col-mandatory');
                    th.title = '필수 열은 제거할 수 없습니다.';
                } else {
                    th.classList.add('col-selectable-header');
                    if (selectedColIndices.has(initialIdx)) {
                        th.classList.add('col-selected');
                    }
                    th.addEventListener('click', (e) => handleStep3ColClick(e, initialIdx));
                }
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            step3PreviewTableEl.appendChild(thead);
            
            const tbody = document.createElement('tbody');
            currentData.slice(0, 100).forEach(row => { // Preview up to 100 rows for performance
                const tr = document.createElement('tr');
                row.forEach((cell, currentIdx) => {
                    const initialIdx = state.step3.initialHeader.indexOf(currentHeader[currentIdx]);
                    const td = document.createElement('td');
                    td.textContent = cell;
                    if (selectedColIndices.has(initialIdx) && !mandatoryColIndices.has(initialIdx)) {
                        td.classList.add('col-selected');
                    }
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            step3PreviewTableEl.appendChild(tbody);
        }

        function handleStep3ColClick(event, initialColIndex) {
            const { selectedColIndices, mandatoryColIndices } = state.step3;
            if(mandatoryColIndices.has(initialColIndex)) return;

            if (!event.ctrlKey && !event.metaKey) {
                selectedColIndices.clear();
            }

            if(selectedColIndices.has(initialColIndex)) {
                selectedColIndices.delete(initialColIndex);
            } else {
                selectedColIndices.add(initialColIndex);
            }
            renderStep3Table();
        }

        function handleRemoveCols() {
            if (state.step3.selectedColIndices.size === 0) {
                alert('제거할 열을 먼저 선택해주세요.');
                return;
            }
            
            state.step3.selectedColIndices.forEach(index => {
                state.step3.removedColIndices.add(index);
            });
            
            const indicesToRemove = state.step3.removedColIndices;
            
            state.step3.currentHeader = state.step3.initialHeader.filter((_, index) => !indicesToRemove.has(index));
            state.step3.currentData = state.step3.initialData.map(row => {
                return row.filter((_, index) => !indicesToRemove.has(index));
            });
            
            state.step3.selectedColIndices.clear();
            renderStep3Table();
        }


        function handleResetStep3() {
            state.step3.currentData = JSON.parse(JSON.stringify(state.step3.initialData));
            state.step3.currentHeader = [...state.step3.initialHeader];
            state.step3.selectedColIndices.clear();
            state.step3.removedColIndices.clear(); 
            identifyMandatoryColumns();
            renderStep3Table();
        }
        
        function handleExportExcel() {
            if (typeof XLSX === 'undefined') {
                alert("엑셀 라이브러리를 로드하는 중입니다. 잠시 후 다시 시도해주세요.");
                return;
            }

            const wb = XLSX.utils.book_new();

            // Function for simple sheets
            const addNumberedSheet = (sheetName, header, data) => {
                const numberedHeader = ["순번", ...header];
                const numberedData = data.map((row, index) => [index + 1, ...row]);
                const sheetData = [numberedHeader, ...numberedData];
                const ws = XLSX.utils.aoa_to_sheet(sheetData);
                XLSX.utils.book_append_sheet(wb, ws, sheetName);
            };

            // --- Generate sheets 1, 2, 3 (no style) ---
            const originalHeader = state.originalRawData[0];
            const originalData = state.originalRawData.slice(1);
            addNumberedSheet("원본", originalHeader, originalData);
            
            const cardNameHeader = state.step2.header.find(h => String(h).includes("신용카드명"));
            const cardNameIndex = cardNameHeader ? state.step2.header.indexOf(cardNameHeader) : -1;

            let inquiryDataForSheet = state.step2.currentData;
            if (cardNameIndex !== -1) {
                inquiryDataForSheet = inquiryDataForSheet.filter(row => row[cardNameIndex] && String(row[cardNameIndex]).trim() !== '');
            }
            addNumberedSheet("업체 문의 거래내역", state.step2.header, inquiryDataForSheet);

            const finalInquiryRowsSet = new Set(state.step2.currentData.map(row => JSON.stringify(row)));
            const remainingData = originalData.filter(row => !finalInquiryRowsSet.has(JSON.stringify(row)));
            addNumberedSheet("문의하지 않은 나머지", state.step2.header, remainingData);

            // --- Generate sheet 4 (with style) ---
            // 1. Prepare data and headers
            let finalDataForSheet = state.step3.currentData;
            const cleanedFinalHeader = state.step3.currentHeader.map(h => String(h).replace(/\s*\(.*\)\s*/g, '').trim());
            const newColumnsHeader = ["원 거래처명", "원 사업자번호", "상세 사용내역(품목)"];
            const styledHeader = ["순번", ...cleanedFinalHeader, ...newColumnsHeader];
            
            const finalCardNameHeader = cleanedFinalHeader.find(h => String(h).includes("신용카드명"));
            const finalCardNameIndex = finalCardNameHeader ? cleanedFinalHeader.indexOf(finalCardNameHeader) : -1;
            
            if (finalCardNameIndex !== -1) {
                 finalDataForSheet = finalDataForSheet.filter(row => row[finalCardNameIndex] && String(row[finalCardNameIndex]).trim() !== '');
            }

            const styledData = finalDataForSheet.map((row, index) => [index + 1, ...row, "", "", ""]);

            // 2. Add informational header
            const infoHeader = [
                ["카드매입내역 확인"],
                ["결제대행사 등의 실제 판매자의 정보를 기입해주세요."],
                ["결제 대행사 거래내용 파악 예시 :"],
                ["1) 네이버 : 네이버홈페이지 > Npay클릭 > 우측 영수증 조회/출력 > 카드영수증 > 받기 > PDF받기"],
                ["2) 쿠팡 : 마이쿠팡 > 좌측 영수증 조회/출력 > 신용카드 매출전표 > 기간설정 > 영수증신청하기 클릭 > 신청내역 출력"],
            ];
            const sheetDataForStyle = [...infoHeader, [], styledHeader, ...styledData];
            
            const ws = XLSX.utils.aoa_to_sheet(sheetDataForStyle);

            // 3. Define Styles
            const headerStyle = { font: { bold: true, sz: 11, color: { rgb: "FFFFFFFF" } }, fill: { fgColor: { rgb: "FF4F81BD" } }, alignment: { horizontal: "center", vertical: "center" } };
            const inputColumnStyle = { fill: { fgColor: { rgb: "FFFFFF00" } } }; // Yellow fill
            const infoHeader1Style = { font: { bold: true, sz: 16 }, alignment: { horizontal: "center", vertical: "center" } };
            const infoHeader2Style = { font: { sz: 11 }, alignment: { horizontal: "center", vertical: "center" } };
            const infoHeader3Style = { font: { bold: true, sz: 10 }, alignment: { horizontal: "left", vertical: "center" } };
            const infoHeader45Style = { font: { sz: 10 }, alignment: { horizontal: "left", vertical: "center" } };
            const numFmtStyle = { numFmt: "#,##0" };

            // 4. Apply Styles & Merges
            const dataHeaderRow = 6; // Row index for the actual data header (0-based)
            const totalCols = styledHeader.length;
            const inputColsStart = totalCols - 3;
            const sumAmountIndexInStyled = styledHeader.indexOf("합계금액");


            ws['!merges'] = [
                { s: { r: 0, c: 0 }, e: { r: 0, c: totalCols - 1 } },
                { s: { r: 1, c: 0 }, e: { r: 1, c: totalCols - 1 } },
                { s: { r: 2, c: 0 }, e: { r: 2, c: totalCols - 1 } },
                { s: { r: 3, c: 0 }, e: { r: 3, c: totalCols - 1 } },
                { s: { r: 4, c: 0 }, e: { r: 4, c: totalCols - 1 } },
            ];

            // Style info headers
            ws[XLSX.utils.encode_cell({r:0, c:0})].s = infoHeader1Style;
            ws[XLSX.utils.encode_cell({r:1, c:0})].s = infoHeader2Style;
            ws[XLSX.utils.encode_cell({r:2, c:0})].s = infoHeader3Style;
            ws[XLSX.utils.encode_cell({r:3, c:0})].s = infoHeader45Style;
            ws[XLSX.utils.encode_cell({r:4, c:0})].s = infoHeader45Style;


            for(let C = 0; C < totalCols; ++C) {
                // Style data header
                ws[XLSX.utils.encode_cell({r: dataHeaderRow, c: C})].s = headerStyle;
                // Apply styles to data rows
                for(let R = dataHeaderRow + 1; R < sheetDataForStyle.length; ++R) {
                    const cellAddress = XLSX.utils.encode_cell({r: R, c: C});
                    if(!ws[cellAddress]) ws[cellAddress] = {};
                    
                    let appliedStyle = {};
                    
                    // Style input columns
                    if (C >= inputColsStart) {
                        appliedStyle = {...appliedStyle, ...inputColumnStyle};
                    }

                    // Style sum amount column
                    if (C === sumAmountIndexInStyled) {
                        if (ws[cellAddress].v && !isNaN(parseFloat(String(ws[cellAddress].v).replace(/,/g, '')))) {
                            ws[cellAddress].t = 'n';
                            ws[cellAddress].v = parseFloat(String(ws[cellAddress].v).replace(/,/g, ''));
                        }
                        appliedStyle = {...appliedStyle, ...numFmtStyle};
                    }
                    
                    ws[cellAddress].s = appliedStyle;
                }
            }
            
            // 5. Auto Column Width (based on data starting from row 7)
            const dataForWidthCalc = [styledHeader, ...styledData];
            const colWidths = dataForWidthCalc[0].map((_, i) => {
                const maxWidth = dataForWidthCalc.reduce((w, r) => {
                    const cellValue = r[i] === null || r[i] === undefined ? '' : String(r[i]);
                    // For number-formatted columns, calculate width based on formatted string
                    if (i === sumAmountIndexInStyled && !isNaN(parseFloat(cellValue))) {
                        const formattedValue = parseFloat(cellValue).toLocaleString('en-US');
                        return Math.max(w, formattedValue.length);
                    }
                    return Math.max(w, cellValue.length);
                }, 0);
                return { wch: maxWidth + 2 }; // Add padding
            });

            ws['!cols'] = colWidths;
            
            XLSX.utils.book_append_sheet(wb, ws, "업체 전송내역");

            // --- Write and Download File ---
            XLSX.writeFile(wb, state.fileName);
        }
        
        // --- Merge Workflow Functions ---
        
        function handleMergeFile(event) {
            const file = event.target.files[0];
            if (!file) return;
            mergeState.fileName = file.name.replace(/\.(xlsx|xls)$/, '') + '_정리완료.xlsx';
            const reader = new FileReader();
            reader.onload = (e) => {
                const data = new Uint8Array(e.target.result);
                const workbook = XLSX.read(data, { type: 'array' });
                const sheetName = workbook.SheetNames[0];
                const worksheet = workbook.Sheets[sheetName];
                mergeState.replyData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                mergeState.currentStep = 'selectHeader';
                updateUI();
            };
            reader.readAsArrayBuffer(file);
        }

        function renderMergePreviewTable() {
            mergePreviewTable.innerHTML = '';
            const previewData = mergeState.replyData.slice(0, 20);
            const tbody = document.createElement('tbody');
            previewData.forEach((row, rowIndex) => {
                const tr = document.createElement('tr');
                tr.classList.add('row-selectable');
                if (mergeState.replyHeaderIndex === rowIndex) tr.classList.add('highlight-row');
                tr.addEventListener('click', () => {
                    mergeState.replyHeaderIndex = rowIndex;
                    mergeConfirmHeaderBtn.disabled = false;
                    renderMergePreviewTable();
                });
                row.forEach((cell) => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            mergePreviewTable.appendChild(tbody);
        }

        function handleMergeConfirmHeader() {
            if (mergeState.replyHeaderIndex === null) return;
            mergeState.replyHeader = mergeState.replyData[mergeState.replyHeaderIndex];
            mergeState.currentStep = 'mapColumns';
            updateUI();
        }

        function renderMergeMap() {
            mergeSourceCols.innerHTML = '';
            // Filter out already mapped columns from the source list
            const mappedCols = new Set([...mergeState.mappings.map(m => m.reply), ...mergeState.mappings.map(m => m.original)]);
            mergeState.replyHeader.forEach(colName => {
                if (mappedCols.has(colName)) return; // Don't show if already used
                const div = document.createElement('div');
                div.textContent = colName;
                div.className = 'list-item p-2 border rounded bg-white';
                div.draggable = true;
                div.dataset.colName = colName;
                div.addEventListener('dragstart', e => {
                    e.dataTransfer.setData('text/plain', colName);
                    div.classList.add('dragging');
                });
                div.addEventListener('dragend', () => div.classList.remove('dragging'));
                mergeSourceCols.appendChild(div);
            });

            mergeMapPairs.innerHTML = '';
            mergeState.mappings.forEach((mapping, index) => {
                 const replyItem = mapping.reply ? `<span class="mapped-item bg-blue-100 text-blue-800 p-2 rounded" title="클릭하여 제거" onclick="removeMergeMapping(${index}, 'reply')">${mapping.reply}</span>` : '덮어쓰는 값';
                 const originalItem = mapping.original ? `<span class="mapped-item bg-green-100 text-green-800 p-2 rounded" title="클릭하여 제거" onclick="removeMergeMapping(${index}, 'original')">${mapping.original}</span>` : '덮어쓰기 대상';

                 const pairHtml = `
                    <div class="p-4 border rounded-lg shadow-sm">
                         <p class="font-medium text-center mb-2">${mapping.label}</p>
                         <div class="grid grid-cols-2 gap-4 items-center">
                            <div data-map-index="${index}" data-map-type="reply" class="drop-zone border-2 border-dashed rounded-md p-2 text-center bg-slate-50">
                                ${replyItem}
                            </div>
                            <div data-map-index="${index}" data-map-type="original" class="drop-zone border-2 border-dashed rounded-md p-2 text-center bg-slate-50">
                               ${originalItem}
                            </div>
                        </div>
                    </div>
                `;
                mergeMapPairs.insertAdjacentHTML('beforeend', pairHtml);
            });

            document.querySelectorAll('.drop-zone').forEach(zone => {
                zone.addEventListener('dragover', e => {
                    e.preventDefault();
                    zone.classList.add('drag-over');
                });
                zone.addEventListener('dragleave', () => zone.classList.remove('drag-over'));
                zone.addEventListener('drop', e => {
                    e.preventDefault();
                    zone.classList.remove('drag-over');
                    const colName = e.dataTransfer.getData('text/plain');
                    const mapIndex = parseInt(zone.dataset.mapIndex);
                    const mapType = zone.dataset.mapType;
                    
                    const otherType = mapType === 'reply' ? 'original' : 'reply';
                    if (mergeState.mappings[mapIndex][otherType] === colName) {
                        alert("동일한 열을 '덮어쓰는 값'과 '대상'으로 지정할 수 없습니다.");
                        return;
                    }

                    mergeState.mappings[mapIndex][mapType] = colName;
                    renderMergeMap();
                });
            });
        }
        
        function removeMergeMapping(mapIndex, mapType) {
            mergeState.mappings[mapIndex][mapType] = null;
            renderMergeMap();
        }


        function handleMergeConfirmMap() {
            if (mergeState.mappings.some(m => !m.reply || !m.original)) {
                alert("모든 항목을 매핑해주세요.");
                return;
            }

            const replyDataRows = mergeState.replyData.slice(mergeState.replyHeaderIndex + 1);
            const header = [...mergeState.replyHeader];

            const processedData = replyDataRows.map(row => {
                const newRow = [...row];
                mergeState.mappings.forEach(m => {
                    const replyIndex = header.indexOf(m.reply);
                    const originalIndex = header.indexOf(m.original);
                    
                    if (replyIndex > -1 && originalIndex > -1) {
                        const replyValue = newRow[replyIndex];
                        if (replyValue && String(replyValue).trim() !== '' && String(replyValue).trim() !== '0') {
                            newRow[originalIndex] = replyValue;
                        }
                    }
                });
                return newRow;
            });
            
            const replyColsToRemove = new Set(mergeState.mappings.map(m => m.reply));
            const indicesToRemove = header.map((h, i) => replyColsToRemove.has(h) ? i : -1).filter(i => i !== -1);
            
            mergeState.finalHeader = header.filter((_, index) => !indicesToRemove.includes(index));
            mergeState.finalData = processedData.map(row => row.filter((_, index) => !indicesToRemove.includes(index)));

            mergeState.currentStep = 'preview';
            updateUI();
        }
        
        function renderMergeFinalPreview() {
            mergeFinalPreviewTable.innerHTML = '';
            const thead = document.createElement('thead');
            const tr = document.createElement('tr');
            mergeState.finalHeader.forEach(title => {
                const th = document.createElement('th');
                th.textContent = title;
                tr.appendChild(th);
            });
            thead.appendChild(tr);
            mergeFinalPreviewTable.appendChild(thead);

            const tbody = document.createElement('tbody');
            mergeState.finalData.forEach(row => {
                const tr = document.createElement('tr');
                row.forEach(cell => {
                    const td = document.createElement('td');
                    td.textContent = cell;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            mergeFinalPreviewTable.appendChild(tbody);
        }

        function handleMergeExport() {
            const ws = XLSX.utils.aoa_to_sheet([mergeState.finalHeader, ...mergeState.finalData]);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, "정리된 내역");
            XLSX.writeFile(wb, mergeState.fileName);
        }


        // --- Main UI Controller ---
        function updateUI() {
            // Hide all major containers first
            initialChoiceContainer.classList.add('hidden');
            inquiryWorkflowContainer.classList.add('hidden');
            mergeWorkflowContainer.classList.add('hidden');

            if (appState.mode === 'initial') {
                initialChoiceContainer.classList.remove('hidden');
            } else if (appState.mode === 'inquiry') {
                inquiryWorkflowContainer.classList.remove('hidden');
                stepContainers.forEach(container => container.classList.add('hidden'));
                stepNavs.forEach((nav, index) => {
                    nav.classList.remove('step-active', 'step-complete', 'step-inactive');
                    if (index + 1 < state.mainStep) nav.classList.add('step-complete');
                    else if (index + 1 === state.mainStep) nav.classList.add('step-active');
                    else nav.classList.add('step-inactive');
                });
                stepContainers[state.mainStep - 1].classList.remove('hidden');
                if (state.mainStep === 1) {
                    uploadStepEl.classList.add('hidden');
                    processingStepEl.classList.add('hidden');
                    clientSelectionStepEl.classList.add('hidden');
                    if(state.step1.currentSubStep === 'upload') {
                         uploadStepEl.classList.remove('hidden');
                    } else if (state.step1.currentSubStep === 'select-header') {
                        processingStepEl.classList.remove('hidden');
                        instructionEl.textContent = '1. 제목 행을 클릭해주세요.';
                        renderStep1Table();
                    } else if (state.step1.currentSubStep === 'select-column') {
                        processingStepEl.classList.remove('hidden');
                        instructionEl.textContent = '2. 거래처명이 있는 열을 클릭해주세요.';
                        state.clientColIndex = null;
                        renderStep1Table();
                    } else if (state.step1.currentSubStep === 'select-clients') {
                        clientSelectionStepEl.classList.remove('hidden');
                        renderClientLists();
                    }
                } else if (state.mainStep === 2) {
                    renderStep2Table();
                } else if (state.mainStep === 3) {
                    renderStep3Table();
                }
            } else if (appState.mode === 'merge') {
                mergeWorkflowContainer.classList.remove('hidden');
                mergeUploadStep.classList.add('hidden');
                mergeHeaderStep.classList.add('hidden');
                mergeMapStep.classList.add('hidden');
                mergePreviewStep.classList.add('hidden');

                if (mergeState.currentStep === 'upload') {
                    mergeUploadStep.classList.remove('hidden');
                } else if (mergeState.currentStep === 'selectHeader') {
                    mergeHeaderStep.classList.remove('hidden');
                    renderMergePreviewTable();
                } else if (mergeState.currentStep === 'mapColumns') {
                    mergeMapStep.classList.remove('hidden');
                    renderMergeMap();
                } else if (mergeState.currentStep === 'preview') {
                    mergePreviewStep.classList.remove('hidden');
                    renderMergeFinalPreview();
                }
            }
        }
    </script>
</body>
</html>


